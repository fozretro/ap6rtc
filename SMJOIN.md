# SMJoin ROM Relocation and Chaining Documentation

## Overview

This document captures the BBC Micro ROM relocation and chaining mechanisms used by SMJoin and related tools. The understanding was developed through analysis of three key sources:

1. **[MDFS JoinROM documentation](https://mdfs.net/Info/Comp/BBC/SROMs/JoinROM.htm)** - Describes the final chained structure
2. **MiniRom.bas & AP6 ROM source** - Show how to make ROMs joinable (with relocation data)
3. **SMJoin.bas implementation** - Reveals the actual joining process and chaining mechanism

## Understanding the Process

Initially, there was confusion about the relationship between these sources. The MDFS documentation describes service entry points pointing to "spare space" that calls original handlers, but the ROM sources showed service entries pointing directly to their own handlers. 

The breakthrough came when it was realized:
- **Individual ROMs** (MiniRom.bas, AP6) are structured to be **joinable** (with relocation data)
- **SMJoin.bas** performs the **joining process** by relocating ROMs and inserting chaining code
- **MDFS documentation** describes the **final result** after SMJoin processing

The complete process involves three phases: making ROMs joinable, joining them with SMJoin, and the resulting chained execution flow.

## Complete ROM Joining Process

### Phase 1: Making ROMs Joinable (Individual ROM Sources)
**MiniRom.bas & AP6 ROM Source show how to structure ROMs for joining:**
- **Language Entry (0-2)**: `EQUB &00:EQUW RelocTable` - Points to relocation table
- **Service Entry (3-5)**: `JMP ServiceHandler` - Points to own service handler  
- **Copyright & Length (6-7)**: `EQUB &82:EQUB RelocTableEnd-RomStart` - Standard header + reloc table length
- **Relocation Data**: Generated by `PROCsm_table` at end of code
- **Service Handler**: Handles service calls and returns (doesn't chain)

### Phase 2: ROM Joining Process (SMJoin.bas)
**When SMJoin loads each ROM:**
1. **Detects relocation data** from language entry pointing to relocation table
2. **Relocates the ROM** using the relocation data to new address
3. **Modifies service entry** to implement chaining:
   - Changes `JMP ServiceHandler` to `JMP NewModuleStart`
   - At `NewModuleStart`: Inserts `JSR PreviousHandler; LDX &F4` + relocated ROM code
4. **Links modules together** in a chain

### Phase 3: Final Chained Structure (MDFS Documentation)
**Result after SMJoin processing:**
```
8000   JMP MYLANG           ; Language entry (if language ROM)
8003   JMP NewStart3        ; Service entry points to newest module
...
Service1: \ Original service handler
...
NewStart3: JSR NewStart2    ; Call previous module (inserted by SMJoin)
           LDX &F4          ; Restore X register
           Service3: ...    ; ROM 3's service code
NewStart2: JSR Service1     ; Call original handler (inserted by SMJoin)  
           LDX &F4          ; Restore X register
           Service2: ...    ; ROM 2's service code
```

### Execution Flow
**When a service call happens, execution flows through the chain in reverse order:**
1. OS calls &8003 → JMP NewStart3
2. NewStart3: JSR NewStart2 → JSR Service1 → Service1 executes → returns
3. NewStart2: LDX &F4 → Service2 executes → returns  
4. NewStart3: LDX &F4 → Service3 executes → returns to OS

## Step-by-Step Instructions for SMJoin Compatibility

The approach for making a ROM SMJoin-compatible depends on how the ROM is compiled and what tools are available. There are two main methods:

- **Method A**: For ROMs compiled with BBC BASIC, which has built-in relocation generation capabilities
- **Method B**: For ROMs compiled with other assemblers (BeebAsm, Lancs Assembler, etc.), which require post-processing tools

Both methods achieve the same result: a ROM with proper relocation data that SMJoin can process, but they use different techniques to generate that relocation data.

### Method A: BBC BASIC ROMs (MiniRom.bas, AP6v133.src)

This method shows how `MiniRom.bas` implements SMJoin compatibility using BBC BASIC's built-in relocation generation.

#### ROM Header Structure (MiniRom.bas)
```basic
.RomStart
BRK:EQUW RelocTable          \ Offsets 0-2: Language entry
JMP Service                  \ Offsets 3-5: Service entry
EQUB &82:EQUB Copyright-RomStart  \ Offsets 6-7: Copyright + reloc table length
```

#### Dual Compilation Control (MiniRom.bas)
```basic
DEFFNsm_pass(pass%)
IFpass%=0:M%=0
IFpass%=1:M%=O%-mcode%
P%=&8100-128*(pass%AND2)     \ Pass 0: &8100, Pass 2: &8000
O%=mcode%+M%*(pass%AND2)DIV2 \ Memory layout for dual compilation
IFpass%=1:IF O%+M%*2.125>L%:PRINT"Code overrun":END
=VALMID$("4647",pass%+1,1)   \ Return 4 for pass 0, 7 for pass 2
```

#### Relocation Data Generation (MiniRom.bas)
```basic
DEFPROCsm_table
base80%=mcode%+M%:base81%=mcode%:byte%=0:count%=0:off%=0:REPEAT
byte80%=base80%?off%:byte81%=base81%?off%:IF off%>=M%:byte80%=&80:byte81%=&80
IF ((byte81%-byte80%) AND &FE)<>0 THEN PRINT "ERROR: Offset by more than one page at &";~&8000+off%
IF (byte80% AND &C0)=&80:byte%=byte%DIV2+128*(byte81%-byte80%):count%=count%+1
IF count%=8:?O%=byte%:O%=O%+1:byte%=0:count%=0
off%=off%+1:UNTILoff%>=M% AND count%=0
ENDPROC
```

#### Main Assembly Process (MiniRom.bas)
```basic
PROCassem(0):CLEAR:PROCassem(2):PROCsm_table
A$="*SAVE "+fname$+" "+STR$~(mcode%+M%)+" "+STR$~O%+" FFFF0000 FFFBBC00"
PRINTA$;:OSCLIA$:PRINT
```

**Process:**
1. **`PROCassem(0)`**: Assemble at `&8100` (pass 0)
2. **`CLEAR`**: Clear memory
3. **`PROCassem(2)`**: Assemble at `&8000` (pass 2) 
4. **`PROCsm_table`**: Generate relocation data by comparing the two builds
5. **`*SAVE`**: Save final ROM with relocation data

### Method B: Non-BBC BASIC ROMs (BeebAsm, Lancs Assembler, etc.)

For ROMs that cannot use BBC BASIC's `PROCsm_table` function, use the Node.js post-processing approach:

#### Step 1: Dual Compilation Setup
**Create a build script that compiles your ROM twice:**

1. **First compilation** at address `$8000`:
   ```bash
   # Compile ROM at $8000
   ./assembler source.asm -o rom_8000.bin
   ```

2. **Second compilation** at address `$8100`:
   ```bash
   # Modify ORG directive to $8100
   sed -i 's/ORG.*\$8000/ORG \$8100/' source.asm
   # Compile ROM at $8100  
   ./assembler source.asm -o rom_8100.bin
   ```

#### Step 2: Run Node.js Relocation Tool
**Use the Node.js tool to generate SMJoin-compatible ROM:**
```bash
node smjoin-reloc-data.js rom_8000.bin rom_8100.bin output_rom.bin
```

#### Step 3: What the Node.js Tool Does
**The tool automatically performs these modifications to create a SMJoin-compatible ROM:**

1. **Compares the two ROM builds** byte-by-byte to identify relocatable addresses
2. **Generates compressed relocation data** (bitmap of which bytes need relocation)
3. **Modifies the ROM header** to be SMJoin-compatible:
   - **Language Entry (0-2)**: Changes `DFB 0,0,0` to `BRK + RelocTable address`
   - **Service Entry (3-5)**: Keeps existing `JMP ServiceHandler` unchanged
   - **Relocation Length (7)**: Updates to actual relocation table length
4. **Appends relocation data** to the end of the ROM
5. **Outputs final ROM** ready for SMJoin processing

#### Step 4: ROM Header Changes Summary
**Input ROM header:**
```assembly
romstart    DFB    0,0,0             \no language entry (3 nulls)
            JMP    service           \to service entry  
            DFB    $82               \ROM type : Service + 6502 code
            DFB    (copyr-romstart)  \offset to copyright string
```

**Output ROM header (SMJoin-compatible):**
```assembly
romstart    BRK                       \dummy language entry
            EQUW    RelocTable        \address to relocation table
            JMP     service           \to service entry (unchanged)
            DFB     $82               \ROM type : Service + 6502 code  
            DFB     RelocTableLength  \relocation table length
            ; ... ROM code ...
            ; ... relocation data appended at end ...
```

#### Step 5: Integration with SMJoin
**The output ROM can now be processed by SMJoin:**
- SMJoin detects the relocation data via the language entry
- SMJoin relocates the ROM to its final position
- SMJoin modifies the service entry to implement chaining
- ROM becomes part of the service call chain

## ROM Chaining Mechanism

Many ROMs programs do not use the full 8K or 16K of the ROM, and have spare space in them. You can use this spare space to add extra ROM code. This is fairly easy to do as long as no more than one component of a multi-code ROM claims memory or provides a language. The simplest method is to add purely service code to an existing ROM.

To do this, you need the image of the ROM you are adding to, and the source code (or a method of relocating the image) for the ROM code you want to add. This is done by changing the destination of the service call entry at &8003 to the start of the spare space at the end of the ROM. At the start of this spare space, the new code firstly calls the old service handler, and then continues with the new code's service handler:

**Original ROM:**
```
8003   JMP SERV              \ Service entry
...
SERV   \ Service handler
```

**After adding new code:**
```
8003   JMP MYCODE            \ New service entry
...
SERV   \ Original service handler
...
MYCODE JSR SERV              \ Call original handler
...    \ My service handler
```

The additional code can even be a relocated ROM image with the language entry point in the first three bytes changed to the JSR SERV instruction. The following instruction will then be the relocated jump to the additional service handler.

Any number of ROM code fragments can be joined together like this. However, as each fragment is independent of each other, only one can claim workspace and use the workspace byte at &DF0+rom, and only one can be a language and be entered at &8000. To be entered as a language, the entry at &8000 should be changed to jump to the ROM code fragment's entry point:

**Original ROM:**
```
8000   BRK:BRK:BRK           \ No language entry
8003   JMP SERV              \ Service entry
```

**After adding language:**
```
8000   JMP MYLANG            \ New language entry
8003   JMP MYCODE            \ New service entry
...
SERV   \ Original service handler
...
MYCODE JSR SERV              \ Call original handler
...    \ My service handler
MYLANG \ My language startup
```

*Source: [MDFS JoinROM Documentation](https://mdfs.net/Info/Comp/BBC/SROMs/JoinROM.htm)*

## Two-Pass Assembly for Relocation Data Generation

The key to making ROMs joinable is generating relocation data that tells the system which bytes contain addresses that need to be adjusted when the ROM is moved to a different memory location.

### The Process
1. **First Pass**: Assemble the ROM code at address `&8000`
2. **Second Pass**: Assemble the same ROM code at address `&8100` 
3. **Compare**: Byte-by-byte comparison to find address differences
4. **Generate**: Create a compressed bitmap of which bytes need relocation

### Memory Layout
- **First half of buffer**: Pass 0 output (assembled at &8000)
- **Second half of buffer**: Pass 1 output (assembled at &8100)
- **Relocation table**: At the end, pointed to by ROM header

### Address Detection
The system looks for bytes that differ by exactly 1 page (256 bytes) between the two assemblies. This indicates address high bytes that need relocation:
- **&8000 assembly**: `JMP $8024` becomes `4C 24 80`
- **&8100 assembly**: `JMP $8124` becomes `4C 24 81`
- **Difference**: High byte changed from `80` to `81` (exactly 1 page)

### Relocation Bitmap Generation
- Each byte is checked: `(byte80% AND &C0)=&80` (address high byte pattern)
- If difference is ±1 page: mark for relocation (bit = 1)
- Pack 8 relocation bits into each output byte
- Store compressed bitmap at end of ROM

### ROM Header Structure
```
Byte 0: BRK ($00) - dummy language entry
Bytes 1-2: Word pointer to RelocTable (relocation bitmap address)
Bytes 3-5: JMP Service - service call entry point
Byte 6: ROM type/flags (&82 = service ROM with copyright)
Byte 7: Copyright pointer offset from RomStart
```

### Service Call Chaining
When ROMs are joined, SMJoin modifies the service entry points to create a chain:
1. **Original**: `8003 JMP SERV` (points to service handler)
2. **Modified**: `8003 JMP NewStart` (points to new module)
3. **New Module**: `JSR PreviousHandler` + `LDX &F4` + new service code

### Execution Flow
Service calls flow through the chain in reverse order (newest first):
1. OS calls &8003 → JMP NewStart3
2. NewStart3: JSR NewStart2 → JSR Service1 → Service1 executes → returns
3. NewStart2: LDX &F4 → Service2 executes → returns  
4. NewStart3: LDX &F4 → Service3 executes → returns to OS

This allows multiple ROMs to handle the same service calls, with each getting a chance to process the call before passing it to the next ROM in the chain.

## References

- [MDFS JoinROM Documentation](https://mdfs.net/Info/Comp/BBC/SROMs/JoinROM.htm)
- MiniRom.bas implementation (`src.smjoin/MiniRom.bas`)
- AP6 ROM source (`src.AP6v133/AP6v133.src`)
- I2C ROM source (`src.i2c/I2CBeeb.asm`)
- SMJoin tool (`src.smjoin/SMJoin.bas`)
